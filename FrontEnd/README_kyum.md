## SSR(Server Side Rendering)

- 렌더링 하는 주체자는 서버
- 요청시 렌더링(미리 렌더링 하는 것이 아닌, 클라이언트가 요청할 때 서버에서 렌더링하고 렌더링 한 결과를 클라이언트에게 보내줌)
- 클라이언트가 request/home을 요청하면, 서버는 **DB**에서 데이터를 읽어오거나 **클라우드**의 네트워크에서 네트워크를 가지고 와야 된다면, 서버에서 HTML 파일을 만들어서 만들어진 HTML 파일을 클라이언트에게 보내줌
- SSG(빌드할 때 한번), ISR(주기적으로 미리 렌더링)하는 것과 달리, 클라이언트에서 요청이 올 때 그 때마다 서버에서 HTML을 만들어서 줌
- 장점
    - SSG와 ISG의 장점과 동일
        - TTV 빠름
        - JS 필요없음
        - SEO 최적화 좋음
        - 보안이 뛰어남
        - **실시간 데이터를 사용**
        - **사용자별 필요한 데이터를 사용**
- 단점
    - 요청할 때마다, 서버에서 렌더링을 해서 클라이언트에게 주기 때문에 SSG, ISR보다 상대적으로 느림
    - 서버의 과부하가 걸릴 수 있음(**서버의 오버헤드가 높아진다**)
        - 페이지 전체를 SSR 하게 되면
    - CDN에 캐시가 안됨

**결론: 하나의 완벽한 렌더링 솔루션은 없음**

## Next.js에서 제공해주는 Hybrid 웹앱

- 필요에 따라 두개 이상(CSR, SSG, ISR, SSG)의 기능이나 요소를 결합하여 성능 좋은 앱 만듬
- 가장 최적화된 방식을 선택
- 한 페이지 내에서도 SSR, CSR을 섞는 등 하이브리드 형태로 만듬

### Hydration(하이브리드가 가능하게 하는 Next.js 기능)

- 기존, 클라이언트는 서버에게 페이지 요청을 함 → 필요한 것(data, network)을 받아와서 정적인 HTML을 만듬
    - 서버에서 사용자에게 의미있는 데이터를 먼저 보여주기 위해서, 이 페이지에는 ~~한 UI 요소가 있어, 이것 먼저 구성해서 정적인 HTML을 만듬 → **pre-redering**
- 사용자가 이를 받으면, 정적인 HTML 코드만 받은 상태
- 그 이후에 React, JS 파일을 보내줌
    - 정적인 HTML 페이지 + React, js ⇒ 물을 주는 것과 비슷(**Hyderate**)
    - ⇒ 컴포넌트 렌더링
- [정리]
    - 사용자에게 빠르게 페이지를 보여주기 위해서 서버는 먼저 정적인 HTML 페이지를 넘겨줌
        - 그 뒤에 서버가 페이지 인터렉션 처리를 위한 React, JS 코드를 보내줌
        - 클라이언트가 React, JS를 다 다운로드 받으면
        - Hyderation을 해줌
            - 리액트로 물을 가득 채움
            - 정적인 HTML 페이지 대신에, 실제 컴포넌트를 쓸 수 있게 해줌
    - 정적인 HTML에서 Hyderation 이후의 모습 간의 간극을 줄여 나가는 것이 키포인트
        - 잘못 만들게 되면 정적인 HTML이 렌더링되고, Hyderation 이후 화면 깜박임이 발생

## 웹앱 개발시 중요한 포인트

- 웹 사이트를 개발시 **TTV와 TTI**(Time To Interact)를 최소로 하는 것이 정말 중요함